# NFT Contract Scripts

This directory contains scripts to interact with the Soroban NFT contract. The scripts allow you to create collections, mint NFTs, transfer tokens, and query contract data.

## Prerequisites

1. **Deploy your NFT contract** to Stellar testnet or mainnet
2. **Set up environment variables**:
   - Copy `.env.example` to `.env`: `cp .env.example .env`
   - Update the `CONTRACT_ID` in `.env` with your deployed contract ID
   - The default configuration is set for Stellar Testnet
3. **Have a funded Stellar account** with XLM for transaction fees
4. **Install dependencies**: `yarn install`

## Available Scripts

### 1. Create Collection

Creates a new NFT collection.

```bash
yarn create-collection <name> <symbol> <base-uri> <secret-key>
```

**Parameters:**

- `name`: Human-readable collection name (e.g., "My Art Collection")
- `symbol`: Short collection symbol (e.g., "ART")
- `base-uri`: Base URI for metadata (e.g., "https://api.myart.com/metadata/")
- `secret-key`: Secret key of the collection creator (SXXX...)

**Example:**

```bash
yarn create-collection "Digital Art Collection" "DART" "https://api.digitalart.com/" "SXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
```

**Output:**

```
üöÄ Creating collection...
üìù Name: Digital Art Collection
üî§ Symbol: DART
üîó Base URI: https://api.digitalart.com/
üë§ Creator: GXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
üîç Simulating transaction...
üì° Submitting transaction...
‚è≥ Waiting for confirmation...
‚úÖ Collection created successfully!
üÜî Transaction Hash: abc123...
üéØ Collection ID: 0
```

### 2. Mint NFT

Mints a new NFT in an existing collection. The metadata URI is automatically generated by combining the collection's base URI with the token ID.

```bash
yarn mint <collection-id> <recipient-address> <secret-key>
```

**Parameters:**

- `collection-id`: ID of the target collection (number)
- `recipient-address`: Address that will receive the NFT (GXXX...)
- `secret-key`: Secret key of the minter (SXXX...)

**Example:**

```bash
yarn mint 0 "GXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" "SXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
```

**Output:**

```
üé® Minting NFT...
üÜî Collection ID: 0
üìß Recipient: GXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
üìÑ Auto-generated URI: https://api.digitalart.com/0
üéØ Expected Token ID: 0
üë§ Minter: GXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
üîç Simulating transaction...
üì° Submitting transaction...
‚è≥ Waiting for confirmation...
‚úÖ NFT minted successfully!
üÜî Transaction Hash: def456...
üéØ Token ID: 0
```

**Note:** The URI is automatically generated as `base_uri + token_id`. For example, if the collection has base URI "https://api.digitalart.com/" and you're minting token ID 5, the final URI will be "https://api.digitalart.com/5".

### 3. Transfer NFT

Transfers an NFT to a new owner.

```bash
yarn transfer <collection-id> <token-id> <to-address> <from-secret-key>
```

**Parameters:**

- `collection-id`: ID of the collection (number)
- `token-id`: ID of the token within the collection (number)
- `to-address`: Address of the new owner (GXXX...)
- `from-secret-key`: Secret key of the current owner (SXXX...)

**Example:**

```bash
yarn transfer 0 1 "GXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" "SXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
```

**Output:**

```
üìÆ Transferring NFT...
üÜî Collection ID: 0
üéØ Token ID: 1
üì§ From: GXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
üì• To: GXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
üîç Simulating transaction...
üì° Submitting transaction...
‚è≥ Waiting for confirmation...
‚úÖ NFT transferred successfully!
üÜî Transaction Hash: ghi789...
```

### 4. Query Contract Data

Query various information from the contract without making transactions.

```bash
yarn query <command> [params...]
```

**Available Commands:**

#### Get Collection Information

```bash
yarn query collection <collection-id>
```

Example: `yarn query collection 0`

#### Get Token Information

```bash
yarn query token <collection-id> <token-id>
```

Example: `yarn query token 0 1`

#### Get Token Owner

```bash
yarn query owner <collection-id> <token-id>
```

Example: `yarn query owner 0 1`

#### Get Tokens Owned by Address

```bash
yarn query tokens <owner-address>
```

Example: `yarn query tokens GXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX`

#### Get Total Collections

```bash
yarn query total-collections
```

#### Get Total Tokens in Collection

```bash
yarn query total-tokens <collection-id>
```

Example: `yarn query total-tokens 0`

## Environment Setup

The scripts automatically load configuration from a `.env` file using dotenv.

### Quick Setup

1. **Copy the example environment file**:

   ```bash
   cp .env.example .env
   ```

2. **Update the contract ID** (already set to the testnet deployment):

   ```env
   CONTRACT_ID=CB7BSQKL7YKQSD6LQ46RRAFYJNZKAFGFFDKQQ5D6ZP4MG6ZYBDF7AEVU
   RPC_URL=https://soroban-testnet.stellar.org
   NETWORK_PASSPHRASE=Test SDF Network ; September 2015
   ```

3. **Run scripts directly** (no need to export variables):
   ```bash
   yarn create-collection "My Collection" "MC" "https://api.example.com/" "SXXX..."
   ```

### Custom Configuration

You can override any environment variable by setting it in your `.env` file:

```env
# Use a different RPC endpoint
RPC_URL=https://my-custom-rpc.example.com

# Use mainnet instead of testnet
NETWORK_PASSPHRASE=Public Global Stellar Network ; September 2015
```

## Complete Workflow Example

Here's a complete example of creating a collection and minting NFTs:

```bash
# 1. Set up environment
export CONTRACT_ID="CXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"

# 2. Create a collection
yarn create-collection "Pixel Art Collection" "PIXEL" "https://api.pixelart.com/metadata/" "SXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
# Output: Collection ID: 0

# 3. Mint NFT to yourself
yarn mint 0 "GXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" "pixel1.json" "SXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
# Output: Token ID: 0

# 4. Mint NFT to someone else
yarn mint 0 "GYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY" "pixel2.json" "SXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
# Output: Token ID: 1

# 5. Check collection info
yarn query collection 0

# 6. Check who owns token 1
yarn query owner 0 1

# 7. Transfer token 0 to another address
yarn transfer 0 0 "GZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ" "SXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"

# 8. Verify the transfer
yarn query owner 0 0
```

## Error Handling

The scripts include comprehensive error handling:

- **Invalid parameters**: Clear error messages with usage examples
- **Network errors**: Retry logic and detailed error reporting
- **Transaction failures**: Simulation errors are caught before submission
- **Missing environment variables**: Clear instructions on what's needed

## Security Notes

- **Never commit secret keys** to version control
- **Use environment variables** or secure key management for production
- **Validate recipient addresses** before transfers
- **Test on testnet first** before using mainnet

## Troubleshooting

### Common Issues

1. **"CONTRACT_ID environment variable is required"**

   - Solution: Set the CONTRACT_ID environment variable

2. **"Account not found"**

   - Solution: Ensure your account is funded with XLM for transaction fees

3. **"Simulation failed"**

   - Solution: Check that the collection/token exists and you have permission

4. **Network timeouts**
   - Solution: Check your internet connection and RPC endpoint

### Getting Help

If you encounter issues:

1. Check the error message for specific guidance
2. Verify your environment variables are set correctly
3. Ensure your account has sufficient XLM balance
4. Try the transaction on testnet first

## Script Architecture

Each script follows a consistent pattern:

1. **Parameter validation**: Ensures all required parameters are provided
2. **Environment setup**: Loads configuration and validates requirements
3. **Transaction building**: Creates the appropriate Soroban contract call
4. **Simulation**: Tests the transaction before submission
5. **Execution**: Signs and submits the transaction
6. **Confirmation**: Waits for and reports the final result

This ensures reliable execution and clear feedback for all operations.
